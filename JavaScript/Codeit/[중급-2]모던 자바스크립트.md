# 모던 자바스크립트
## 1. 모던 자바스크립트 이해하기
### 1-1. 모던 자바스크립트란?
- ECMAScript
  - 자바스크립트 표준 명세서
  - 자바스크립트를 사용할때 준수해야하는 규칙이나 세부 사항들을 ECMA-262 문서로 관리
  - ES6 버전은 자바스크립트 발전에 큰 영향 => ES5까지의 자바스크립트가 가진 문제점들을 보완하고, 코드를 좀 더 안전하고 간결하게 작성할 수 있는 유용한 문법들의 등장

- Modern JavaScript
  - 현시점에 사용하기 적합한 범위 내에서 최신 버전의 표준을 준수하는 자바스크립트
  - 새롭게 등장한 문법들 중 유용한 문법과 그 활용법에 대해 살펴볼 예정

- JavaScript vs ECMAScript
  - JavaScript는 프로그래밍 언어, ECMAScript는 프로그래밍 언어의 표준
  - ECMAScript는 JavaScript가 갖추어야 할 내용을 정리해둔 '설명서'
  - JavaScript는 ECMAScript를 준수해서 만들어낸 '결과물'
 
 [ECMA-International 공식 ECMA-262문서](https://www.ecma-international.org/publications-and-standards/standards/ecma-262/)

## 2. 자바스크립트의 동작 원리
### 2-1. 데이터 타입의 특징과 종류
- "데이터 타입이 유연하다." => "상황에 따라 데이터 타입이 변할 수 있다."
- 파이썬의 경우 일반적으로 서로 다른 데이터 타입끼리 연산 불가능 
- 데이터 타입의 구분이 엄격한 C or JAVA의 경우에는 변수에도 따로 데이터 타입을 정해줘야하기 때문에 한 번 타입이 정해진 변수에는 해당 타입의 값만 할당
- __하지만__ 자바스크립트에서는 ```숫자 2``` + ```문자열 "3"``` 을 더하면 ```숫자 2가 문자열 "2"```로 평가되어 ```"23"```
- ```숫자 2```와 ```문자열 "3"```을 곱하면 ```문자열 "3"```이 ```숫자 3```으로 평가되어 ```숫자 6```
- 변수에도 따로 타입을 정해주지 않아 언제든지 다양한 타입의 값으로 재할당 가능
- 자바스크립트를 능숙하게 다루기 위해서는 데이터 타입에 대한 이해가 중요!!
- __결과적으로__ 내가 작성한 코드가 어떤 타입의 값을 리턴하는지 확실하게 알고있어야 함

### 2-2. 불린인 듯 불린 아닌 불린같은 값
#### "데이터 타입은 상황에 따라 변할 수 있다."
```JavaScript
if ('codit') {
  console.log('I love JavaScript! :)');
} else {
  console.log('I hate JavaScript! :(');
}

// console에 출력되는 값 : I love JavaScript! :)
```
  - 그동안 우리가 살펴본 if문의 조건부분에는 보통 ```true```나 ```false```값이 리턴되는 조건식이 들어감
  - 위 코드에서는 문자열이 들어가있음
  - if문의 조건부분에 들어간 ```codeit```이라는 문자열이 ```true```처럼 평가되었다는 뜻
  =>
  - 자바스크립트에서는 ```if```, ```for```, ```while```문의 조건부분처럼 ```Boolean```타입의 값이 필요한 맥락에서는 ```Boolean```이 아닌 다른 타입의 값들도 ```Boolean``` 타입으로 평가
  - 다시말해, ```Boolean```이 아닌 타입의 값이 ```Boolean```타입으로 형변환
  - False로 평가되는 값 : ```flase```, ```null```, ```undefined```, ```NaN```, ```0```, ```''(빈문자열)``` => Falsy 값이라고 부름
  - True로 평가되는 값 : ```나머지 값들!```, ```[]```, ```{}``` => Truthy 값이라고 부름

### 2-3. AND와 OR의 연산 방식
```JavaScript
 //AND 연산
console.log('Codeit' && 'JavaScript');     // 출력 값 : JavaScript

console.log(true && true);                 // 출력 값 : true
console.log(true && false);                // 출력 값 : false
console.log(false && true);                // 출력 값 : false
console.log(false && false);               // 출력 값 : false

// 왼쪽 값이 Truthy하면 오른쪽 값 리턴, 왼쪽 값이 Falsy하면 왼쪽 값을 리턴
```

```JavaScript
 //OR 연산
console.log(true || true);                 // 출력 값 : true
console.log(true || false);                // 출력 값 : true
console.log(false || true);                // 출력 값 : true
console.log(false || false);               // 출력 값 : false

// 왼쪽 값이 Truthy하면 왼쪽 값 리턴, 왼쪽 값이 Falsy하면 오른쪽 값을 리턴
```

```JavaScript
 //AND와 OR의 연산
console.log(null && undefined);      // 출력 값 : null
console.log(0 || true);              // 출력 값 : true
console.log('0' && NaN);             // 출력 값 : NaN
console.log({} || 123);              // 출력 값 : {}
```

```JavaScript
// 응용 버전
function print(value) {
  const message = value || 'Codeit';
  
  console.log(message);
}

print();              // 출력 값 : 'Codeit'
print('JavaScript');  // 출력 값 : value
```

### 2-4. 변수와 스코프 익히기
- 변수가 유효한 시점에 차이
  - 선언이 나중에 되었지만 마치 이 선언이 올라간듯 한 현상 => 호이스팅
  - 호이스팅은 선언 부분만 끌어올려지기 때문에 변수 선언과 동시에 값을 할당하더라도 할당된 값 자체는 그 이후에 접근 가능
  
    ```JavaScript
    // var
    console.log(title);     // undefined
    var title = 'codeit';
    console.log(title);     // codeit
    ```
    
    ```JavaScript
    // let
    console.log(title); 
    let title = 'codeit';
    
    // 선언 이전에 접근할 수 없다 => Uncaught ReferenceError 발생
    ```
 
- 중복 선언 가능 
  - var는 중복 선언 가능 => 실수로 이미 선언한 변수명을 중복으로 선언할 경우 의도치않게 먼저 선언한 값이 사라짐
  - let, const는 중복 선언 불가능 => 같은 이름으로 이미 선언된 변수가 있다. => Uncaught SyntaxError 발생

- 변수의 유효 범위 (스코프의 차이)
  - var 키워드는 변수의 스코프가 함수 단위로 구분 즉, 함수 스코프를 
  - let 키워드는 코드블록 즉, 블록 스코프를 가짐

### :exclamation: 내용 정리 => 자바스크립트의 다양한 변수 선언 방식 
- var 변수
  - 변수 이름 중복선언 가능
  - 변수 선언 전에 사용 가능(호이스팅)
  - 함수 스코프
- let, const
  - 변수 이름 중복선언 불가 (SyntaxError 발생)
  - 변수 선언 전에 사용 불가 (ReferenceError 발생)
  - 블록 스코프


## 3. 함수 다루기
### 3-1. 함수를 만드는 방법
- 함수 선언
  - 선언 전 호출 가능
  - 선언문이 위쪽으로 끌어올려짐 : 호이스팅
  - 함수 스코프를 가짐
  - 함수가 아닌 다른 코드블럭에서 함수를 선언하면 모두 전역적으로 호출 가능
```JavaScript
function 함수이름(파라미터) {
  동작
  return 리턴값
}
```
- 함수 표현식
  - 선언 이전에 접근 불가능
  - 할당된 변수에 따라 스코프 결정
```JavaScript
const printCodeit = function () {
  console.log('Codeit');
};
printCodeit();
```

### 3-2. Parameter & Arguments
- 함수를 호출할때 함수 바깥에서 안쪽으로 다양한 값들을 전달받고자 할때 Parameter 사용
```javaScript
function greeting(name) {
  console.log(`Hi! My name is ${name}!`);
}

// 함수를 호출할때 Parameter로 전달하는 값을 가르켜 Argument라고 함
greeting('JavaScript');
greeting('Codeit');
greeting('World');
```
- Parameter와 Argument 구분 해야함
  - 함수 선언 부분에서 소괄호 안에 작성되는것이 Parameter
  - 함수를 호출하는 부분에서 Parameter로 전달하는 값에 해당하는 부분이 Argument

- 기본값 할당해주는 방법

```javaScript
function greeting(name = 'Codeit') {
  console.log(`Hi! My name is ${name}!`);
}

greeting();
```

### 3-3. Rest Parameter
```javaScript
function printArguments() {
  for (const arg of arguments) {
    console.log(arg);
  }
  console.log('---------');
};

printArguments('Young', 'Mark', 'Koby');
printArguments('Captain');
printArguments('Jayden', 'Scott');
printArguments('Suri', 'Jack', 'Joy', 'Noel');

// 위 코드를 Rest Parameter 방식으로 작성한다면

function printArguments(...args) {
  for (const arg of args) {
    console.log(arg);
  }
  console.log('---------');
};

printArguments('Young', 'Mark', 'Koby');
printArguments('Captain');
printArguments('Jayden', 'Scott');
printArguments('Suri', 'Jack', 'Joy', 'Noel');

```

### 3-4. Arrow Function
- ES2015에서 새롭게 등장
- 기존의 함수 선언 방식을 좀 더 간결하게 만들어주는 문법
- 이름이 없는 익명 함수
- ```Function``` 키워드 대신 ```=>``` 사용

### 3-5. What is this?
- 콘솔에 ```this```를 찍으면 ```window 객체```가 출력
- 함수 내부에서 주로 사용
- 객체의 메소드 만들때 중요한 역할

```javaScript
function getFullName() {
  reurn `${this.firstName} ${this.lastName}`;
}

const user = {
  firstName: 'Tess',
  lastName: 'Jang',
  getFullName: getFullName,
};

const admin = {
  firstName: 'Alex',
  lastName: 'Kim',
  getFullName: getFullName,
};

console.log(user.getFullName());
console.log(admin.getFullName());
```

- 자바스크립트에서의 `this`는 함수를 호출한 객체를 가르키는 키워드
- 코드를 작성할 때 값이 미리 결정되는 것이 아니라 함수를 호출할 때 어떤 객체가 그 함수를 호출했는지에 따라 상대적으로 값이 변하게 된다는 것이 특징


## 4. 자바스크립트의 문법과 표현
### 4-1. 문장과 표현식
- 문장 (statements)
  - 우리가 작성하는 모든 자바스크립트 코드는 모두 문장과 표현식으로 구성
  - 자바스크립트에서 문장은 어떤 동작이 일어나도록 작성된 최소한의 코드 덩어리
- 표현식 (expressions)
  - 결과적으로 하나의 값이 되는 모든 코드를 가리킴
  - 어떤 하나의 값을 그대로 작성하는 것 
  - 길이와는 상관없이 결과적으로 하나의 값이 되는 코드 모두가 ```표현식```

### 4-2. 조건을 다루는 표현식
- ES2015 새롭게 등장한 문법
- 조건 연산자(삼항연산자)
  - ```삼항연산자``` : 조건 ? truthy 할 때 표현식 : falsy 할 때 표현식

   ```javaScript
   const CUT_OFF = 80;
   
   function passChecker(score) {
    return score > CUT_OFF ? '합격!' : '불합격!'
   }
   
   console.log(passChecker(75));
   ```

### 4-3. Spread 구문
- ES2015 새롭게 등장한 문법
- 대괄호로 묶여서 담겨있는 값들이 개별 값으로 펼쳐짐 
- 모습이 rest parameter와 유사하여 차이를 구분해야함
- rest parameter : 여러개의 아규먼트를 하나의 파라미터로 묶는 방식
- Spread 구문 : 하나로 묶여있는 값을 각각의 개별값으로 펼치는 방식
- 배열을 좀 더 편리하게 복사할 수 있음

### 4-4. 모던한 프로퍼티 표기법

```javaScript
const user = {
  title: 'Codeit',
  birth: 2017,
  job: '프로그래밍 강사',
};
```

- 때로는 변수에 할당된 값을 활용하여 프로퍼티의 값을 만들 수 있음

```javaScript
const title = 'Codeit'
const birth = 2017
const job = '프로그래밍 강사'

const user = {
  title: title,
  birth: birth,
  job: job,
};

// 이 경우 변수의 이름과 프로퍼티 네임이 같다면 하나만 작성하는 표현 가능
const user = {
  title,
  birth,
  job,
};
```

### 4-5. 옵셔널 체이닝
- 안전하게 프로퍼티에 접근하기 
- 일반적으로 객체의 프로퍼티는 점표기법을 통해 접근

  ```javaScript
  function printCatName(user) {
    console.log(user.cat?.name);
  }
  ```
  
- 위 코드에서 물음표와 마침표를 붙여 사용하는 부분이 ```옵셔널 체이닝 연산자(?.)```
- 만약 옵셔널 체이닝 연산자 왼편의 프로퍼티 값이 undefined 또는 null이 아니라면 그다음 프로퍼티 값을 리턴하고 그렇지 않은 경우에는 undefined를 반환하는 문법

### 4-6. Destructuring


### 4-7. 함수와 Destructuring


### 4-8. 에러와 에러 객체


### 4-9. try catch 문


### 4-10. try catch 활용하기



## 5. 자바스크립트의 유용한 내부 기능


## 6. 자바스크립트 모듈


## 7. 마무리
