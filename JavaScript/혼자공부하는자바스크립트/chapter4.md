# 반복문
## :heavy_check_mark: 배열
- 배열은 여러 자료를 묶어서 활용할 수 있는 특수한 자료
- 여러 개의 값을 모아놓은 것
- 생성 방법 : [요소, 요소, 요소] : 배열 내부의 값을 '요소' 라고 부를거야!
- 기본 연산
  - a.length : 요소 개수 추출
  - a[인덱스] : 요소 추출
- 기본 메서드
  - a.push(요소) : 뒤에 추가
  - a.splice(인덱스, 0, 요소) : 특정 위치에 요소 추가
  - a.indexOf(요소) : 특정 값의 인덱스 추출
  - a.splice(인덱스, 1) : 인덱스 위치의 요소 제거

### ✅ 배열 뒤에 요소 추가하기 : push(요소)
```javaScript
  const a = [52, 273, '안녕', '하세요']
  
  a.push(100)
  
  a = [52, 273, '안녕', '하세요', 100]
```
### ✅ 배열 중간에 요소 추가하기: splice(인덱스, 0, 요소)
첫 번째 위치에 '추가'라는 녀석을 추가한다고 했을때 1번 위치에 '추가'가 들어감
```javaScript
  const a = [52, 273, '안녕', '하세요', 100]
  
  a.splice(1, 0, '추가')
  
  a = [52, '추가', 273, '안녕', '하세요', 100]
```
### ✅ 인데스로 배열의 요소 제거하기: splice(인덱스, 1)
제거를 원하는 인덱스를 입력 후 그 뒤에 1을 입력
```javaScript
  a.splice(0, 1)
  ▶️ [52]
  
  a = ['추가', 273, '안녕', '하세요', 100]  
```
### ✅ 배열 내부에서 값의 위치 찾기: indexOf(요소)
원하는 요소가 배열에 없으면 -1 출력!
```javaScript
  a = ['추가', 273, '안녕', '하세요', 100]  
  
  a.indexOf('안녕')
  
  2
```
### ✅ 값으로 배열의 요소 제거하기: indexOf() + splice 활용
```javaScript
  const index = a.indexOf('하세요')
  
  a.splice(index, 1)      // 위에서 index는 '하세요'의 위치인 3! => a.splice(3, 1)과 동일한 의미
  ▶️ ['하세요']
  
  a =  ['추가', 273, '안녕', 100]  
```

### ❗어렵지만 이해할 수 있을거야 스택, 힙, 비파괴적 처리, 파괴적 처리!!!!!❗
#### 기본 자료형과 & 복합 자료형
- 기본 자료형보다 복합 자료형이 훨씬 더 크다는걸 생각하고 두 자료형에 대해 정리해보자!!
- 기본 자료형 :
  - 숫자, 문자열 불
  - '스택(stack)' 이라는 곳에 저장 / 착착 쌓아줘
  - 작은 자료들이 쌓이는 형태
- 복합 자료형 : 
  - 배열, 함수, 객체
  - '힙(Heap)' 이라는 곳에 저장 / 무작위로 그냥 막 쌓아둬
  - 아주 큰 자료들이 대충 널려서 쌓이는 형태
- 스택과 힙의 연결 c = [1, 2, 3]
  - 힙의 공간에 [1, 2, 3]이라는 이름의 배열이 만들어지면
  - 컴퓨터 내부에서 이 주소를 나타내는 값을 #1번지라고 하고, 이 #1값을 스택에 넣고 이 공간을 c 라고 이름을 붙여줄거야!!
  - 만약에 내가 consol.log(c)라는 형태로 이 'C'를 사용하면 'C'라는 공간에 있는 내용을 확인할거야 : #1 이겠지? 주소일거야
  - 그리고 이 내용(#1)이 어떤 위치를 나타내는 값이기 때문에 힙에서 이 위치에 있는 배열을 찾아서 출력해줄거야
#### 비파괴적 처리 & 파괴적 처리
- 비파괴적 처리 : 어떠한 처리 후 원본이 변경되지 않는다.  
  - 예시
    ```javaScript
    let a = 10
    leb b = 20
    
    a + b + enter
    30
    
    //하지만 다시
    a + enter
    10
    
    b + enter
    20    
    ```
- 파괴적 처리 : 어떠한 처리 후 원본이 변경된다. 
  - 예시
    ```javaScript
    let c = [1, 2, 3]
    
    c.push(4)
    
    c + enter
    [1, 2, 3, 4]
    ```
- const로 선언할때 스택은 왜 재할당이 불가능하고 힙은 왜 재할당이 가능한가?  기본 자료형은 불가능하고? 복합 자료형은 가능한가?
- 내가 이해한 바는 스택은 비파괴적 처리, 힙은 파괴적 처리 => 
- 그래서 힙에 속해있는 배열은 const로 선언했을때 원본 변경이 가능하고 스택에 속해있는 숫자, 문자열은 const로 선언했을때 원본 변경이 불가능하다.


## :heavy_check_mark: 반복문
- for in 반복문, for of 반복문 = 배열 등과 함께 사용한다. 
- for 반복문은 범용적으로 사용한다. 
### ✅ for in 반복문
  ```javaScript
    for (const 반복 변수 in 배열 또는 객체) {
      문장 
    }
  ```
### ✅ for of 반복문
  ```javaScript
    for (const 반복 변수 of 배열 또는 객체) {
      문장 
    }
  ```
### ✅ for 반복문
  ```javaScript
    for (let i = 0; i < 반복 횟수; i++) {
      문장
    }
  ```
### ✅ while 반복문
- 조건이 중요할 때 사용
  - 결과가 나올 때까지
  - 특정 시간이 될 때까지
  - 파일을 읽으며 특정 단어를 찾을 때까지
  ```javaScript
    while (불 표현식) {
      문장
    }
  ```

## 별찍기 
- 별을 찍어야해 => 별 찍는 것에 대한 반복문
- 별을 찍고, 다음 줄로 넘어가야해 => 다음 줄로 넘어 가는 것에 대한 반복문
- 중첩 반복문을 사용하여 코드 작성 필요!!!
- 반복문 '횟수'에는 표현식도 올 수 있는걸 기억해서 활용하자!!
```javaScript
  *
  **
  ***
  ****
  *****
  ******
  *******
  ********
  *********

  let output = ''

  for (let i = 0; i < 9; i++) {
    for (let j = 0; j < i + 1; j++) {
      output += '*'
    }
    output += '\n'
  }
  console.log(output)
```
